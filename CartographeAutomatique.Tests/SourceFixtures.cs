namespace CartographeAutomatique.Tests;

public static class SourceFixtures
{
    public const string Vector3ClassText = //language=csharp
        @"namespace TestNamespace;

[Generators.MapTo(typeof(Point)]
public partial class Vector3
{
    public float X { get; set; }
    public float Y { get; set; }
    public float Z { get; set; }
}

public partial class Point
{
    public float X { get; set; }
    public float Y { get; set; }
    public float Z { get; set; }
};
";

    public const string MultipleMappingAttributes = //language=csharp
        @"namespace TestNamespace;

[MapTo(typeof(Point))]
[MapTo(typeof(Point2), Exhaustive = false)]
public class Vector3
{
    public float X { get; set; }
    public float Y { get; set; }
    public float Z { get; set; }
}

public class Point
{
    public float X { get; set; }
    public float Y { get; set; }
    public float Z { get; set; }
}

public class Point2
{
    public float X { get; set; }
    public float Y { get; set; }
}
";

    public const string ExpectedGeneratedCodeVector3 =
        //language=csharp
        @"// <auto-generated/>
namespace TestNamespace;

public static partial class Vector3MappingExtensions
{
    public static TestNamespace.Point MapToPoint(this Vector3 source) =>
       new()
       {
            X = source.X,
			Y = source.Y,
			Z = source.Z
       };
}";

    public const string NonExhaustiveMapping =
        //language=csharp
        @"namespace TestNamespace;

[Generators.MapTo(typeof(Point2), Exhaustive = false]
public class Vector3
{
    public float X { get; set; }
    public float Y { get; set; }
    public float Z { get; set; }
}

public class Point2
{
    public float X { get; set; }
    public float Y { get; set; }
};
";

    public const string ExpectedGeneratedCodeNonExhaustive =
        //language=csharp
        @"// <auto-generated/>
namespace TestNamespace;

public static partial class Vector3MappingExtensions
{
    public static TestNamespace.Point2 MapToPoint2(this Vector3 source) =>
       new()
       {
            X = source.X,
			Y = source.Y
       };
}";

    public const string RecursiveMappings =
        //language=csharp
        @"namespace TestNamespace;

[MapTo(typeof(Point2), Exhaustive = false)]
public class Point3
{
    public float X { get; set; }
    public float Y { get; set; }
    public float Z { get; set; }
}

public class Point2
{
    public float X { get; set; }
    public float Y { get; set; }
}

[MapTo(typeof(Line2), Exhaustive = false)]
public class Line3
{
    public Point3 A { get; set; }
    public Point3 B { get; set; }
}

public class Line2
{
    public Point2 A { get; set; }
    public Point2 B { get; set; }
}
";

    public const string RecursiveMappingsExpectedPointMapping =
        //language=csharp
        @"// <auto-generated/>
namespace TestNamespace;

public static partial class Point3MappingExtensions
{
    public static TestNamespace.Point2 MapToPoint2(this Point3 source) =>
       new()
       {
            X = source.X,
			Y = source.Y
       };
}";

    public const string RecursiveMappingsExpectedLineMapping =
        //language=csharp
        @"// <auto-generated/>
namespace TestNamespace;

public static partial class Line3MappingExtensions
{
    public static TestNamespace.Line2 MapToLine2(this Line3 source) =>
       new()
       {
            A = source.A.MapToPoint2(),
			B = source.B.MapToPoint2()
       };
}";

    public const string FieldMappings =
        //language=csharp
        @"
    namespace TestNamespace;

    [MapTo(typeof(SongWriter))]
    class Author
    {
        [TargetMapping(typeof(SongWriter), TargetField = ""FullName"")]
        string Name { get; set; }
    }

    class SongWriter
    {
        string FullName { get; set; }
    }";

    public const string ExpectedFieldMappings =
        //language=csharp
        @"// <auto-generated/>
namespace TestNamespace;

public static partial class AuthorMappingExtensions
{
    public static TestNamespace.SongWriter MapToSongWriter(this Author source) =>
       new()
       {
            FullName = source.Name
       };
}";


}