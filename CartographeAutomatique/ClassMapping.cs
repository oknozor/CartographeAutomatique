using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CartographeAutomatique;

class ClassMapping
{
    private readonly ClassDeclarationSyntax _sourceClass;
    private readonly ClassDeclarationSyntax _targetClass;
    private readonly bool _exhaustive;

    public ClassMapping(ClassDeclarationSyntax sourceClass, ClassDeclarationSyntax targetClass, bool exhaustive)
    {
        _sourceClass = sourceClass;
        _targetClass = targetClass;
        _exhaustive = exhaustive;
    }

    public string GenerateMapping(Compilation compilation)
    {
        var assignations = _exhaustive switch
        {
            false => GenerateAssignationNonExhaustive(),
            true => GenerateAssignationExhaustive(),
        };

        var sourceNameSpace = SourceNameSpace(compilation)!;
        var targetNameSpace = TargetNameSpace(compilation)!;

        var joinedAssignation = string.Join(",\n\t\t\t", assignations);
        return $$"""
                 // <auto-generated/>
                 namespace {{sourceNameSpace}};

                 public partial class {{SourceClassName}}
                 {
                     public {{targetNameSpace}}.{{TargetClassName}} MapTo{{TargetClassName}}() =>
                        new()
                        {
                             {{joinedAssignation}}
                        };
                 }
                 """;
    }

    private List<string> GenerateAssignationExhaustive()
    {
        List<string> assignations = [];
        foreach (var memberDeclarationSyntax in _sourceClass.Members)
        {
            if (memberDeclarationSyntax is not PropertyDeclarationSyntax sourceProperty)
            {
                continue;
            }

            var targetProperty = _targetClass.Members
                .OfType<PropertyDeclarationSyntax>()
                .SingleOrDefault(targetProperty =>
                    targetProperty.Identifier.Text == sourceProperty.Identifier.Text
                    && targetProperty.GetType() == sourceProperty.GetType());

            if (targetProperty is null)
            {
                // TODO emit compiler error
                throw new Exception("invalid mapping");
            }

            assignations.Add($"""{targetProperty.Identifier.Text} = this.{targetProperty.Identifier.Text}""");
        }

        return assignations;
    }

    private List<string> GenerateAssignationNonExhaustive()
    {
        List<string> assignations = [];
        foreach (var memberDeclarationSyntax in _sourceClass.Members)
        {
            if (memberDeclarationSyntax is not PropertyDeclarationSyntax sourceProperty)
            {
                continue;
            }

            var targetProperty = _targetClass.Members
                .OfType<PropertyDeclarationSyntax>()
                .SingleOrDefault(targetProperty =>
                    targetProperty.Identifier.Text == sourceProperty.Identifier.Text
                    && targetProperty.GetType() == sourceProperty.GetType());

            if (targetProperty is not null)
            {
                assignations.Add($"""{targetProperty.Identifier.Text} = this.{targetProperty.Identifier.Text}""");
            }

        }

        return assignations;
    }


    private string? TargetNameSpace(Compilation compilation)
    {
        var sourceSemanticModel = compilation.GetSemanticModel(_targetClass.SyntaxTree);
        if (sourceSemanticModel.GetDeclaredSymbol(_targetClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    public string TargetClassName => _targetClass.Identifier.Text;

    private string? SourceNameSpace(Compilation compilation)
    {
        var sourceSemanticModel = compilation.GetSemanticModel(_sourceClass.SyntaxTree);
        if (sourceSemanticModel.GetDeclaredSymbol(_sourceClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    public string SourceClassName => _sourceClass.Identifier.Text;
}