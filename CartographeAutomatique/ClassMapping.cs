using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CartographeAutomatique;

class ClassMapping(
    ClassDeclarationSyntax sourceClass,
    ClassDeclarationSyntax targetClass,
    bool exhaustive,
    GeneratorSyntaxContext context)
{
    public string GenerateMapping()
    {
        var assignations = GenerateAssignation();
        var sourceNameSpace = SourceNameSpace()!;
        var targetNameSpace = TargetNameSpace()!;

        var joinedAssignation = string.Join(",\n\t\t\t", assignations);
        return $$"""
                 // <auto-generated/>
                 namespace {{sourceNameSpace}};

                 public static partial class {{SourceClassName}}MappingExtensions
                 {
                     public static {{targetNameSpace}}.{{TargetClassName}} MapTo{{TargetClassName}}(this {{SourceClassName}} source) =>
                        new()
                        {
                             {{joinedAssignation}}
                        };
                 }
                 """;
    }

    public string SourceClassName => sourceClass.Identifier.Text;
    public string TargetClassName => targetClass.Identifier.Text;


    private List<string> GenerateAssignation()
    {
        List<string> assignations = [];
        foreach (var memberDeclarationSyntax in sourceClass.Members)
        {
            if (memberDeclarationSyntax is not PropertyDeclarationSyntax sourceProperty)
            {
                continue;
            }

            var matchingTargetMappingAttribute = GetMatchingTargetMappingAttribute(memberDeclarationSyntax);
            var targetField = matchingTargetMappingAttribute?.ArgumentList?
                .Arguments
                .First(arg => arg.NameEquals?.Name.ToString() == "TargetField");

            var targetFieldName = sourceProperty.Identifier.Text;
            
            if (targetField != null)
            {
                var constantValue = context.SemanticModel.GetConstantValue(targetField.Expression);
                if (constantValue is { HasValue: true, Value: string targetMappingFieldName })
                {
                    targetFieldName = targetMappingFieldName;
                }
            }
            
            var targetProperty = targetClass.Members
                .OfType<PropertyDeclarationSyntax>()
                .SingleOrDefault(targetProperty =>
                    targetProperty.Identifier.Text == targetFieldName
                    && targetProperty.GetType() == sourceProperty.GetType());

            if (targetProperty is null)
            {
                if (exhaustive is false)
                    continue;

                throw new Exception("invalid mapping");
            }

            var propertyTypeSymbol = targetProperty.GetPropertyTypeSymbol(context);
            assignations.Add(!propertyTypeSymbol!.IsPrimitiveType()
                ? $"""{targetProperty.Identifier.Text} = source.{sourceProperty.Identifier.Text}.MapTo{propertyTypeSymbol!.Name}()"""
                : $"""{targetProperty.Identifier.Text} = source.{sourceProperty.Identifier.Text}""");
        }

        return assignations;
    }

    private string? TargetNameSpace()
    {
        if (ModelExtensions.GetDeclaredSymbol(context.SemanticModel, targetClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }
    
    private string? SourceNameSpace()
    {
        if (ModelExtensions.GetDeclaredSymbol(context.SemanticModel, sourceClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    private AttributeSyntax? GetMatchingTargetMappingAttribute(MemberDeclarationSyntax memberDeclarationSyntax) =>
        memberDeclarationSyntax
            .AttributeLists
            .SelectMany(x => x.Attributes)
            .Where(a => a.Name is IdentifierNameSyntax { Identifier.ValueText: "TargetMapping" })
            .SingleOrDefault(x =>
                x.ArgumentList != null && x.ArgumentList.Arguments
                    .Any(arg =>
                        arg.Expression is TypeOfExpressionSyntax { Type: IdentifierNameSyntax identifierNameSyntax } &&
                        identifierNameSyntax.Identifier.Text == TargetClassName)
            );
}