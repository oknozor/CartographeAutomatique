using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CartographeAutomatique;

class ClassMapping(
    ClassDeclarationSyntax sourceClass,
    ClassDeclarationSyntax targetClass,
    bool exhaustive,
    GeneratorSyntaxContext context)
{
    public string GenerateMapping()
    {
        var assignations = exhaustive switch
        {
            false => GenerateAssignationNonExhaustive(),
            true => GenerateAssignationExhaustive(),
        };

        var sourceNameSpace = SourceNameSpace()!;
        var targetNameSpace = TargetNameSpace()!;

        var joinedAssignation = string.Join(",\n\t\t\t", assignations);
        return $$"""
                 // <auto-generated/>
                 namespace {{sourceNameSpace}};

                 public static partial class {{SourceClassName}}MappingExtensions
                 {
                     public static {{targetNameSpace}}.{{TargetClassName}} MapTo{{TargetClassName}}(this {{SourceClassName}} source) =>
                        new()
                        {
                             {{joinedAssignation}}
                        };
                 }
                 """;
    }

    private List<string> GenerateAssignationExhaustive()
    {
        List<string> assignations = [];
        foreach (var memberDeclarationSyntax in sourceClass.Members)
        {
            if (memberDeclarationSyntax is not PropertyDeclarationSyntax sourceProperty)
            {
                continue;
            }

            var targetProperty = targetClass.Members
                .OfType<PropertyDeclarationSyntax>()
                .SingleOrDefault(targetProperty =>
                    targetProperty.Identifier.Text == sourceProperty.Identifier.Text
                    && targetProperty.GetType() == sourceProperty.GetType());

            if (targetProperty is null)
            {
                // TODO emit compiler error
                throw new Exception("invalid mapping");
            }

            assignations.Add($"""{targetProperty.Identifier.Text} = this.{targetProperty.Identifier.Text}""");
        }

        return assignations;
    }

    private List<string> GenerateAssignationNonExhaustive()
    {
        List<string> assignations = [];
        foreach (var memberDeclarationSyntax in sourceClass.Members)
        {
            if (memberDeclarationSyntax is not PropertyDeclarationSyntax sourceProperty)
            {
                continue;
            }

            var targetProperty = targetClass.Members
                .OfType<PropertyDeclarationSyntax>()
                .SingleOrDefault(targetProperty =>
                    targetProperty.Identifier.Text == sourceProperty.Identifier.Text
                    && targetProperty.GetType() == sourceProperty.GetType());

            if (targetProperty is not null)
            {
                assignations.Add($"""{targetProperty.Identifier.Text} = source.{targetProperty.Identifier.Text}""");
            }
        }

        return assignations;
    }


    private string? TargetNameSpace()
    {
        if (context.SemanticModel.GetDeclaredSymbol(targetClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    public string TargetClassName => targetClass.Identifier.Text;

    private string? SourceNameSpace()
    {
        if (context.SemanticModel.GetDeclaredSymbol(sourceClass) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    public string SourceClassName => sourceClass.Identifier.Text;
}