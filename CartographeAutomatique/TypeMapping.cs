using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CartographeAutomatique;

public enum MappingStrategyInternal
{
    Constructor,
    Setter
}

internal class TypeMapping(
    TypeDeclarationSyntax sourceType,
    TypeDeclarationSyntax targetType,
    bool exhaustive,
    MappingStrategyInternal strategy,
    GeneratorSyntaxContext context)
{
    public string GenerateMapping()
    {
        var activeStrategy = TargetIsRecord() switch
        {
            true => MappingStrategyInternal.Constructor,
            _ => strategy
        };

        var assignations = GenerateAllAssignation(activeStrategy);
        var sourceNameSpace = SourceNameSpace()!;
        var targetNameSpace = TargetNameSpace()!;

        var joinedAssignation = activeStrategy switch
        {
            MappingStrategyInternal.Setter => string.Join(",\n\t\t\t", assignations),
            MappingStrategyInternal.Constructor => string.Join(",", assignations),
            _ => throw new ArgumentOutOfRangeException()
        };

        var instantiation = activeStrategy switch
        {
            MappingStrategyInternal.Setter => $"\tnew()\n\t\t{{\n\t\t\t{joinedAssignation}\n\t\t}};",
            MappingStrategyInternal.Constructor => $"\tnew({joinedAssignation});",
            _ => throw new ArgumentOutOfRangeException()
        };

        return $$"""
                 // <auto-generated/>
                 namespace {{sourceNameSpace}};

                 public static partial class {{SourceClassName}}MappingExtensions
                 {
                     public static {{targetNameSpace}}.{{TargetClassName}} MapTo{{TargetClassName}}(this {{SourceClassName}} source) =>
                        {{instantiation}}
                 }
                 """;
    }

    public string SourceClassName => sourceType.Identifier.Text;
    public string TargetClassName => targetType.Identifier.Text;


    private List<string> GenerateAllAssignation(MappingStrategyInternal activeStrategy) =>
        (GetSourceProperties() ?? Array.Empty<PropertyOrParameter>())
        .Select(prop => GenerateAssignation(activeStrategy, prop))
        .Where(prop => prop != null)
        .Select(prop => prop!)
        .ToList();

    private string? GenerateAssignation(MappingStrategyInternal activeStrategy, PropertyOrParameter sourceProp)
    {
        var targetField = sourceProp.TargetField();
        var targetFieldName = sourceProp.Identifier;

        if (targetField != null)
        {
            var constantValue = context.SemanticModel.GetConstantValue(targetField.Expression);
            if (constantValue is { HasValue: true, Value: string targetMappingFieldName })
            {
                targetFieldName = targetMappingFieldName;
            }
        }

        var targetProp = GetMatchingTargetProp(targetFieldName, activeStrategy);

        if (targetProp is null)
        {
            if (exhaustive is false)
                return null;

            throw new Exception("invalid mapping");
        }

        var targetTypeSymbol = targetProp.Type.GetPropertyTypeSymbol(context);
        var sourceTypeSymbol = sourceProp.Type.GetPropertyTypeSymbol(context);

        var lhs = activeStrategy switch
        {
            MappingStrategyInternal.Constructor => $"{targetProp.Identifier}: ",
            MappingStrategyInternal.Setter => $"{targetProp.Identifier} = ",
            _ => throw new ArgumentOutOfRangeException(nameof(activeStrategy), activeStrategy, null)
        };

        var methodName = GetCustomMethodMapping(sourceProp);
        var maybeListConversion = GetListImplicitConversion(sourceProp, targetTypeSymbol, sourceTypeSymbol);
        var implicitConversion = GetImplicitConversion(sourceProp.Identifier, targetTypeSymbol, sourceTypeSymbol);

        var rhs = methodName ?? implicitConversion ?? maybeListConversion ?? (!targetTypeSymbol!.IsPrimitiveType()
            ? $"source.{sourceProp.Identifier}.MapTo{targetTypeSymbol!.Name}()"
            : $"source.{sourceProp.Identifier}");

        return $"{lhs}{rhs}";
    }

    private string? GetCustomMethodMapping(PropertyOrParameter sourceProp)
    {
        var customMethod = sourceProp.WithMethod();
        if (customMethod == null) return null;
        var constantValue = context.SemanticModel.GetConstantValue(customMethod.Expression);
        return constantValue is { HasValue: true, Value: string methodNameValue } ? $"{methodNameValue}(source.{sourceProp.Identifier})" : null;
    }

    private static string? GetListImplicitConversion(PropertyOrParameter sourceProp, INamedTypeSymbol? targetTypeSymbol,
        INamedTypeSymbol? sourceTypeSymbol)
    {
        string? maybeListConversion = null;
        if (!targetTypeSymbol.IsCollection1() || !sourceTypeSymbol.IsCollection1()) return maybeListConversion;

        var sourceGenericParameter = sourceTypeSymbol!.FirstGenericParameterName();
        var targetGenericParameter = targetTypeSymbol!.FirstGenericParameterName();
        var hasSameGenericParameter = sourceGenericParameter.Name == targetGenericParameter.Name
                                      && sourceGenericParameter.ContainingNamespace
                                          .ToDisplayString() == targetGenericParameter.ContainingNamespace
                                          .ToDisplayString();

        // TODO: Here we need to handle case where the generic parameter is the same but the collection type should be mapped
        if (hasSameGenericParameter) return null;

        var listMemberConversion = (targetTypeSymbol!.Name, sourceTypeSymbol!.Name) switch
        {
            ("List", "List") =>
                GetImplicitConversion("i", targetGenericParameter, sourceGenericParameter)
                ?? $"i.MapTo{targetGenericParameter.Name}()",
            // Todo : 
            _ => throw new NotImplementedException()
        };

        maybeListConversion = $"source.{sourceProp.Identifier}.Select(i => {listMemberConversion}).ToList()";

        return maybeListConversion;
    }

    private static string? GetImplicitConversion(string sourcePropIdentifier, ITypeSymbol? targetType,
        ITypeSymbol? sourceType)
    {
        var sourceMemberAccess = $"source.{sourcePropIdentifier}";
        return (sourceType?.SpecialType, targetType?.SpecialType) switch
        {
            (SpecialType.System_String, SpecialType.System_Single) => $"Single.Parse({sourceMemberAccess})",
            (SpecialType.System_String, SpecialType.System_Int16) => $"Int16.Parse({sourceMemberAccess})",
            (SpecialType.System_String, SpecialType.System_Int32) => $"Int32.Parse({sourceMemberAccess})",
            (SpecialType.System_String, SpecialType.System_Int64) => $"Int64.Parse({sourceMemberAccess})",
            (SpecialType.System_String, SpecialType.System_UInt16) => $"Int16.Parse({sourceMemberAccess})",
            (SpecialType.System_String, SpecialType.System_UInt32) => $"UInt32.Parse({sourceMemberAccess})",
            (SpecialType.System_String, SpecialType.System_UInt64) => $"UInt64.Parse({sourceMemberAccess})",
            (SpecialType.System_Single, SpecialType.System_String) or
                (SpecialType.System_Int16, SpecialType.System_String) or
                (SpecialType.System_Int32, SpecialType.System_String) or
                (SpecialType.System_Int64, SpecialType.System_String) or
                (SpecialType.System_UInt16, SpecialType.System_String) or
                (SpecialType.System_UInt32, SpecialType.System_String) or
                (SpecialType.System_String, SpecialType.System_Enum) or
                (SpecialType.System_UInt64, SpecialType.System_String) =>
                $"{sourceMemberAccess}.ToString(System.Globalization.CultureInfo.InvariantCulture)",
            _ => null
        };
    }

    private PropertyOrParameter? GetMatchingTargetProp(string targetFieldName, MappingStrategyInternal activeStrategy)
    {
        if (targetType is ClassDeclarationSyntax targetClass && activeStrategy == MappingStrategyInternal.Constructor)
        {
            var constructor = targetClass.Members
                .OfType<ConstructorDeclarationSyntax>()
                .OrderByDescending(c => c.ParameterList.Parameters.Count) // Sort by parameter count
                .FirstOrDefault();

            return constructor?.ParameterList.Parameters
                .Select(targetParameter =>
                    new PropertyOrParameter(targetParameter.Type, targetParameter.Identifier.Text,
                        GetGenericTypeArguments(targetParameter)))
                .SingleOrDefault(targetParameter => targetParameter.Identifier == targetFieldName);
        }

        return targetType switch
        {
            ClassDeclarationSyntax classDeclaration => classDeclaration.Members
                .OfType<PropertyDeclarationSyntax>()
                .Select(targetParameter =>
                    new PropertyOrParameter(targetParameter.Type, targetParameter.Identifier.Text,
                        GetGenericTypeArguments(targetParameter)))
                .SingleOrDefault(targetProperty => targetProperty.Identifier == targetFieldName),

            RecordDeclarationSyntax recordDeclaration => recordDeclaration.ParameterList?
                .Parameters
                .Select(targetParameter =>
                    new PropertyOrParameter(targetParameter.Type, targetParameter.Identifier.Text,
                        GetGenericTypeArguments(targetParameter)))
                .SingleOrDefault(targetParameter => targetParameter.Identifier == targetFieldName),
            _ => throw new ArgumentOutOfRangeException()
        };
    }

    private IEnumerable<PropertyOrParameter>? GetSourceProperties() =>
        sourceType switch
        {
            ClassDeclarationSyntax sourceClass => sourceClass.Members
                .OfType<PropertyDeclarationSyntax>()
                .Select(member =>
                    (Member: member, Attribute: member.GetMatchingMappingAttribute(TargetClassName)))
                .Select(type =>
                    new PropertyOrParameter(type.Member.Type, type.Member.Identifier.Text,
                        GetGenericTypeArguments(type.Member), type.Attribute)),

            RecordDeclarationSyntax sourceRecord => sourceRecord
                .ParameterList?
                .Parameters
                .ToList()
                .Select(parameter => (Parameter: parameter,
                    Attribute: parameter.GetMatchingMappingAttribute(TargetClassName)))
                .Select(type =>
                    new PropertyOrParameter(type.Parameter.Type, type.Parameter.Identifier.Text,
                        GetGenericTypeArguments(type.Parameter), type.Attribute)),
            _ => throw new ArgumentOutOfRangeException(nameof(sourceType), sourceType, null)
        };

    private string? TargetNameSpace()
    {
        if (context.SemanticModel.GetDeclaredSymbol(targetType) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    private string? SourceNameSpace()
    {
        if (context.SemanticModel.GetDeclaredSymbol(sourceType) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    private bool TargetIsRecord() => targetType is RecordDeclarationSyntax;


    private ImmutableArray<ITypeSymbol>? GetGenericTypeArguments(PropertyDeclarationSyntax propertyDeclarationSyntax)
    {
        if (context.SemanticModel.GetDeclaredSymbol(propertyDeclarationSyntax) is not IPropertySymbol propertySymbol)
        {
            return null;
        }

        if (propertySymbol.Type is not INamedTypeSymbol { IsGenericType: true } namedType) return null;
        var genericArguments = namedType.TypeArguments;
        return genericArguments;
    }

    private ImmutableArray<ITypeSymbol>? GetGenericTypeArguments(ParameterSyntax parameterSyntax)
    {
        if (context.SemanticModel.GetDeclaredSymbol(parameterSyntax) is not IParameterSymbol propertySymbol)
        {
            return null;
        }

        if (propertySymbol.Type is not INamedTypeSymbol { IsGenericType: true } namedType) return null;
        var genericArguments = namedType.TypeArguments;
        return genericArguments;
    }
}