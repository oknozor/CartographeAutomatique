using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CartographeAutomatique;

public enum MappingStrategyInternal
{
    Constructor,
    Setter
}

internal class TypeMapping(
    TypeDeclarationSyntax sourceType,
    TypeDeclarationSyntax targetType,
    bool exhaustive,
    MappingStrategyInternal strategy,
    GeneratorSyntaxContext context)
{
    public string GenerateMapping()
    {
        var activeStrategy = TargetIsRecord() switch
        {
            true => MappingStrategyInternal.Constructor,
            _ => strategy
        };

        var assignations = GenerateAssignation(activeStrategy);
        var sourceNameSpace = SourceNameSpace()!;
        var targetNameSpace = TargetNameSpace()!;

        var joinedAssignation = activeStrategy switch
        {
            MappingStrategyInternal.Setter => string.Join(",\n\t\t\t", assignations),
            MappingStrategyInternal.Constructor => string.Join(",", assignations),
        };

        var instantiation = activeStrategy switch
        {
            MappingStrategyInternal.Setter => $"\tnew()\n\t\t{{\n\t\t\t{joinedAssignation}\n\t\t}};",
            MappingStrategyInternal.Constructor => $"\tnew({joinedAssignation});",
        };

        return $$"""
                 // <auto-generated/>
                 namespace {{sourceNameSpace}};

                 public static partial class {{SourceClassName}}MappingExtensions
                 {
                     public static {{targetNameSpace}}.{{TargetClassName}} MapTo{{TargetClassName}}(this {{SourceClassName}} source) =>
                        {{instantiation}}
                 }
                 """;
    }

    public string SourceClassName => sourceType.Identifier.Text;
    public string TargetClassName => targetType.Identifier.Text;


    private List<string> GenerateAssignation(MappingStrategyInternal activeStrategy)
    {
        List<string> assignations = [];

        var sourceProperties = GetSourceProperties();

        if (sourceProperties == null) return assignations;

        foreach (var sourceProp in sourceProperties)
        {
            var customMethod = sourceProp.WithMethod();
            string? methodName = null;

            if (customMethod != null)
            {
                var constantValue = context.SemanticModel.GetConstantValue(customMethod.Expression);
                if (constantValue is { HasValue: true, Value: string methodNameValue })
                {
                    methodName = methodNameValue;
                }
            }

            var targetField = sourceProp.TargetField();
            var targetFieldName = sourceProp.Identifier;

            if (targetField != null)
            {
                var constantValue = context.SemanticModel.GetConstantValue(targetField.Expression);
                if (constantValue is { HasValue: true, Value: string targetMappingFieldName })
                {
                    targetFieldName = targetMappingFieldName;
                }
            }

            var targetProp = GetMatchingTargetProp(targetFieldName, activeStrategy);


            if (targetProp is null)
            {
                if (exhaustive is false)
                    continue;

                throw new Exception("invalid mapping");
            }


            var targetType = targetProp.Type.GetPropertyTypeSymbol(context);
            var sourceType = sourceProp.Type.GetPropertyTypeSymbol(context);

            string? implicitConversion = null;
            if (customMethod is null)
            {
                implicitConversion = GetImplicitConversion(targetType, sourceType);
            }
            var assignation = activeStrategy switch
            {
                MappingStrategyInternal.Constructor when implicitConversion is not null =>
                    $"""{targetProp.Identifier}: {implicitConversion}(source.{sourceProp.Identifier})""",
                MappingStrategyInternal.Constructor when methodName is not null =>
                    $"""{targetProp.Identifier}: {methodName}(source.{sourceProp.Identifier})""",
                MappingStrategyInternal.Setter when methodName is not null =>
                    $"""{targetProp.Identifier} = {methodName}(source.{sourceProp.Identifier})""",
                MappingStrategyInternal.Setter when implicitConversion is not null =>
                    $"""{targetProp.Identifier} = {implicitConversion}(source.{sourceProp.Identifier})""",
                MappingStrategyInternal.Constructor => !targetType!.IsPrimitiveType()
                    ? $"""{targetProp.Identifier}: source.{sourceProp.Identifier}.MapTo{targetType!.Name}()"""
                    : $"""{targetProp.Identifier}: source.{sourceProp.Identifier}""",
                MappingStrategyInternal.Setter => !targetType!.IsPrimitiveType()
                    ? $"""{targetProp.Identifier} = source.{sourceProp.Identifier}.MapTo{targetType!.Name}()"""
                    : $"""{targetProp.Identifier} = source.{sourceProp.Identifier}""",
                _ => throw new ArgumentOutOfRangeException(),
            };

            assignations.Add(assignation);
        }

        return assignations;
    }

    private static string? GetImplicitConversion(ITypeSymbol? targetType, ITypeSymbol? sourceType)
    {

        // Handle conversion for special type (no clue if int, float, double etc will appear here)
        var implicitMapping = (targetType?.SpecialType, sourceType?.SpecialType) switch
        {
            (SpecialType.System_String, SpecialType.System_Int16) => "Int16.Parse",
            (SpecialType.System_String, SpecialType.System_Int32) => "Int32.Parse",
            (SpecialType.System_String, SpecialType.System_Int64) => "Int64.Parse",
            (SpecialType.System_String, SpecialType.System_UInt16) => "Int16.Parse",
            (SpecialType.System_String, SpecialType.System_UInt32) => "UInt32.Parse",
            (SpecialType.System_String, SpecialType.System_UInt64) => "UInt64.Parse",
            // Todo: to drive code generation such as `mySouceEnumVariant.ToString()`
            //      we need a object dedicated to hold the method call generation:
            //      { method: string, call: static_member_access | instance_invocation }
            //      enum -> string (instance_invocation)
            //      int -> string (static_member_access via int.Parse)
            (SpecialType.System_Enum, _) => "ToString()",
            _ => null
            // If no special type were found fallback to name comparison 
            // The example below is not working as we probably need to find a way
            // To extract Generic parameter for collections (or pass the generic parameter in this method call).
            // This needs further exploration in the ITypeSymbol public API.
        } ?? (targetType?.Name, sourceType?.Name) switch
        {
            ("List<MyType>", "MyType[]") => $"ToString()",
            _ => null
        };

        return implicitMapping;
    }

    private PropertyOrParameter? GetMatchingTargetProp(string targetFieldName, MappingStrategyInternal activeStrategy)
    {
        if (targetType is ClassDeclarationSyntax targetClass && activeStrategy == MappingStrategyInternal.Constructor)
        {
            var constructor = targetClass.Members
                .OfType<ConstructorDeclarationSyntax>()
                .OrderByDescending(c => c.ParameterList.Parameters.Count) // Sort by parameter count
                .FirstOrDefault();

            return constructor?.ParameterList?
                .Parameters
                .Select(targetParameter =>
                    new PropertyOrParameter(targetParameter.Type, targetParameter.Identifier.Text))
                .SingleOrDefault(targetParameter => targetParameter.Identifier == targetFieldName);
        }

        return targetType switch
        {
            ClassDeclarationSyntax classDeclaration => classDeclaration.Members
                .OfType<PropertyDeclarationSyntax>()
                .Select(targetParameter =>
                    new PropertyOrParameter(targetParameter.Type, targetParameter.Identifier.Text))
                .SingleOrDefault(targetProperty => targetProperty.Identifier == targetFieldName),

            RecordDeclarationSyntax recordDeclaration => recordDeclaration.ParameterList?
                .Parameters
                .Select(targetParameter =>
                    new PropertyOrParameter(targetParameter.Type, targetParameter.Identifier.Text))
                .SingleOrDefault(targetParameter => targetParameter.Identifier == targetFieldName),
            _ => throw new NotImplementedException()
        };
    }

    private IEnumerable<PropertyOrParameter>? GetSourceProperties() =>
        sourceType switch
        {
            ClassDeclarationSyntax sourceClass => sourceClass.Members
                .OfType<PropertyDeclarationSyntax>()
                .Select(member =>
                    (Member: member, Attribute: member.GetMatchingMappingAttribute(TargetClassName)))
                .Select(type =>
                    new PropertyOrParameter(type.Member.Type, type.Member.Identifier.Text, type.Attribute)),

            RecordDeclarationSyntax sourceRecord => sourceRecord
                .ParameterList?
                .Parameters
                .ToList()
                .Select(parameter => (Parameter: parameter,
                    Attribute: parameter.GetMatchingMappingAttribute(TargetClassName)))
                .Select(type =>
                    new PropertyOrParameter(type.Parameter.Type, type.Parameter.Identifier.Text, type.Attribute)),
            _ => throw new ArgumentOutOfRangeException(nameof(sourceType), sourceType, null)
        };

    private string? TargetNameSpace()
    {
        if (context.SemanticModel.GetDeclaredSymbol(targetType) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    private string? SourceNameSpace()
    {
        if (context.SemanticModel.GetDeclaredSymbol(sourceType) is not INamedTypeSymbol sourceClassSymbol)
            return null;

        return sourceClassSymbol.ContainingNamespace.ToDisplayString();
    }

    private bool TargetIsRecord() => targetType is RecordDeclarationSyntax;
}