using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace CartographeAutomatique;

public enum MappingStrategyInternal
{
    Setter = 1,
    Constructor = 2,
}

public class TypeMapping(
    MappingKind mappingKind,
    INamedTypeSymbol sourceType,
    INamedTypeSymbol targetType,
    bool exhaustive,
    MappingStrategyInternal strategy,
    List<Diagnostic> diagnostics
)
{
    public string GenerateMapping(SourceProductionContext sourceProductionContext)
    {
        foreach (var diagnostic in diagnostics)
            sourceProductionContext.ReportDiagnostic(diagnostic);
        
        var activeStrategy = TargetIsRecord() switch
        {
            true => MappingStrategyInternal.Constructor,
            _ => strategy,
        };

        var assignations = GenerateAllAssignation(activeStrategy);
        var sourceNameSpace = SourceNameSpace()!;
        var targetNameSpace = TargetNameSpace()!;

        var joinedAssignation = activeStrategy switch
        {
            MappingStrategyInternal.Setter => string.Join(",\n\t\t\t", assignations),
            MappingStrategyInternal.Constructor => string.Join(",", assignations),
            _ => throw new ArgumentOutOfRangeException(),
        };

        var instantiation = activeStrategy switch
        {
            MappingStrategyInternal.Setter =>
                $"\tnew()\n\t\t{{\n\t\t\t{joinedAssignation}\n\t\t}};",
            MappingStrategyInternal.Constructor => $"\tnew({joinedAssignation});",
            _ => throw new ArgumentOutOfRangeException(),
        };

        return $$"""
                 // <auto-generated/>
                 namespace {{sourceNameSpace}};

                 public static partial class {{SourceType().Name}}MappingExtensions
                 {
                     public static {{targetNameSpace}}.{{TargetType().Name}} MapTo{{TargetType().Name}}(this {{sourceNameSpace}}.{{SourceType().Name}} source) =>
                        {{instantiation}}
                 }
                 """;
    }


    private List<string> GenerateAllAssignation(MappingStrategyInternal activeStrategy) =>
        (GetSourceProperties() ?? Array.Empty<PropertyOrParameter>())
        .Select(prop => GenerateAssignation(activeStrategy, prop))
        .Where(prop => prop != null)
        .Select(prop => prop!)
        .ToList();

    private string? GenerateAssignation(
        MappingStrategyInternal activeStrategy,
        PropertyOrParameter sourceProp
    )
    {
        var targetFieldName = sourceProp.TargetField() ?? sourceProp.Identifier;
        var targetProp = GetMatchingTargetProp(targetFieldName, activeStrategy);

        if (targetProp is null)
        {
            if (exhaustive is false)
                return null;

            diagnostics.Add(Diagnostic.Create(new DiagnosticDescriptor(
                "CA_EX",
                "CartographeGeneratorError",
                $"No field matching {SourceNameSpace()}.{SourceType().Name}.{targetFieldName} found in {TargetNameSpace()}.{TargetType().Name}",
                "Exhaustive Mapping",
                DiagnosticSeverity.Error,
                isEnabledByDefault: true
            ), SourceType().Locations.First(loc => loc.Kind == LocationKind.SourceFile)));

            return null;
        }

        var targetTypeSymbol = targetProp.Type;
        var sourceTypeSymbol = sourceProp.Type;

        var lhs = activeStrategy switch
        {
            MappingStrategyInternal.Constructor => $"{targetProp.Identifier}: ",
            MappingStrategyInternal.Setter => $"{targetProp.Identifier} = ",
            _ => throw new ArgumentOutOfRangeException(
                nameof(activeStrategy),
                activeStrategy,
                null
            ),
        };

        var methodName = sourceProp.WithMethod();
        var methodCall = methodName is not null ? $"{methodName}(source.{sourceProp.Identifier})" : null;
        var sourceMemberAccess = $"source.{sourceProp.Identifier}";
        var conversion = sourceTypeSymbol.ImplicitConversionTo(
            targetTypeSymbol,
            sourceMemberAccess
        );

        return $"{lhs}{methodCall ?? conversion}";
    }

    private PropertyOrParameter? GetMatchingTargetProp(
        string targetFieldName,
        MappingStrategyInternal activeStrategy
    )
    {
        if (activeStrategy == MappingStrategyInternal.Setter)
        {
            return TargetType().GetMembers()
                .OfType<IPropertySymbol>()
                .Select(prop =>
                    new PropertyOrParameter(prop.Type, prop.Name,
                        prop.GetAttributes().GetMatchingMappingAttribute(TargetType().Name)))
                .SingleOrDefault(targetProperty =>
                    targetProperty.Identifier.CamelCaseEquals(targetFieldName)
                );
        }

        var constructor = TargetType().Constructors
            .OrderByDescending(c => c.Parameters.Length) // Sort by parameter count
            .FirstOrDefault();

        return constructor?.Parameters.Select(targetParameter => new PropertyOrParameter(
                targetParameter.Type,
                targetParameter.Name
            ))
            .SingleOrDefault(targetParameter => targetParameter.Identifier.CamelCaseEquals(targetFieldName));
    }

    private IEnumerable<PropertyOrParameter>? GetSourceProperties()
    {
        if (!SourceType().IsRecord)
            return SourceType().GetMembers()
                .OfType<IPropertySymbol>()
                .Select(prop =>
                    new PropertyOrParameter(prop.Type, prop.Name,
                        prop.GetAttributes().GetMatchingMappingAttribute(TargetType().Name)));
        
        var constructor = SourceType().Constructors
            .OrderByDescending(c => c.Parameters.Length) 
            .FirstOrDefault();

        return constructor?.Parameters.Select(targetParameter => new PropertyOrParameter(
            targetParameter.Type,
            targetParameter.Name,
            targetParameter.GetAttributes().GetMatchingMappingAttribute(TargetType().Name)
        ));
    }

    public string TargetNameSpace() => TargetType().ContainingNamespace.ToDisplayString();

    public string SourceNameSpace() => SourceType().ContainingNamespace.ToDisplayString();

    private bool TargetIsRecord() => TargetType().IsRecord;

    public INamedTypeSymbol SourceType() =>
        mappingKind switch
        {
            MappingKind.MapTo => sourceType,
            MappingKind.MapFrom => targetType,
            _ => throw new ArgumentOutOfRangeException(nameof(mappingKind), mappingKind, null)
        };

    public INamedTypeSymbol TargetType() =>
        mappingKind switch
        {
            MappingKind.MapTo => targetType,
            MappingKind.MapFrom => sourceType,
            _ => throw new ArgumentOutOfRangeException(nameof(mappingKind), mappingKind, null)
        };
}